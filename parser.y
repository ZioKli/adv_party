%{
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "adv.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);



/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0;


%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct adv_bag bag;
		struct item *p_item;
		struct adventurer *p_adventurer;
		struct party a_party;
    int number;
}



%token EOLN
%token LEATHER_BAG_OPEN LEATHER_BAG_CLOSE
%token SILK_BAG_OPEN SILK_BAG_CLOSE
%token CANVAS_BAG_OPEN CANVAS_BAG_CLOSE
%token <string> CHARACTER_NAME
%token <string> ITEM_NAME
%token <string> PORTRAIT
%token <number> NUMBER

%type <p_adventurer> adventurers adv
%type <bag> a_bag leather_bag silk_bag canvas_bag
%type <p_item> items one_item 
%type <a_party> adventuring_party
%type <string> character_name
%type <string> item_name item_names
  

%%

input: adventuring_party
		{
			print_party($1);
		}
	|
		{
	
		}

adventuring_party: adventurers EOLN
		{
			struct party p = {
				strdup($1->name),
				strdup($1->portrait),
				$1
			};
			$$ = p;
		}
	;

adventurers: adv adventurers
		{
			$1->next = $2;
			$$ = $1;
		}
	| adv
	;

adv: PORTRAIT character_name a_bag
		{
			struct adventurer* a = (struct adventurer *) MallocZ(sizeof(struct adventurer));
			a->portrait = $1;
			a->name = $2;
			a->bag = $3;
			a->next = NULL;
			$$ = a;
		}
	;

character_name: CHARACTER_NAME
	| ITEM_NAME
  ;

a_bag: leather_bag
	| silk_bag
	| canvas_bag
	;

leather_bag: LEATHER_BAG_OPEN items LEATHER_BAG_CLOSE
		{
			struct adv_bag b = {
				LEATHER,
				$2
			};
			$$ = b;
		}
	| LEATHER_BAG_OPEN LEATHER_BAG_CLOSE
		{
			struct adv_bag b = {
				LEATHER,
				NULL
			};
			$$ = b;
		}
silk_bag: SILK_BAG_OPEN items SILK_BAG_CLOSE
		{
			struct adv_bag b = {
				SILK,
				$2
			};
			$$ = b;
		}
	| SILK_BAG_OPEN SILK_BAG_CLOSE
		{
			struct adv_bag b = {
				SILK,
				NULL
			};
			$$ = b;
		}
canvas_bag: CANVAS_BAG_OPEN items CANVAS_BAG_CLOSE
		{
			struct adv_bag b = {
				CANVAS,
				$2
			};
			$$ = b;
		}
	| CANVAS_BAG_OPEN CANVAS_BAG_CLOSE
		{
			struct adv_bag b = {
				CANVAS,
				NULL
			};
			$$ = b;
		}
items: one_item items
		{
			$1->next = $2;
			$$ = $1;
		}
	|one_item
	  {
			$$ = $1;
		}
	;

one_item: NUMBER item_names
		{
			struct item *i = (struct item*) MallocZ(sizeof(struct item));
			i->count = $1;
			i->i_name = $2;
			i->next = NULL;
			$$ = i;
		}
	;

item_names: item_name item_names
		{
			int size1 = strnlen($1, 255);
			int size2 = strnlen($2, 255);
			char* name = (char*) MallocZ(size1 + size2);
			strcat(name, $1);
			strcat(name, " ");
			strcat(name, $2);
			$$ = name;
		}
	| item_name
 	;

item_name: ITEM_NAME
	;

%%

void
yyerror(const char *error_string, ...)
{
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;

    fprintf(f,"Error on line %d: ", lines);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}

// You should use this routine instead of malloc() to avoid some memory problems
#include <stdlib.h>
#include <string.h>
void *
MallocZ (int nbytes)
{
    char *ptr = malloc(nbytes);  // use the real routine
    if (ptr == NULL)
	{
	    perror ("MallocZ failed, fatal\n");
	    exit (66);
	}

	// initialize the space to all zeroes
    memset (ptr, '\00', nbytes);

    return (ptr);
}
