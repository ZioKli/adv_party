%{
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "adv.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);



/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0;


%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct adv_bag bag;
		struct item *p_item;
		struct adventurer *p_adventurer;
		struct party a_party;
    int number;
}



%token EOLN
%token LEATHER_BAG_OPEN LEATHER_BAG_CLOSE
%token SILK_BAG_OPEN SILK_BAG_CLOSE
%token CANVAS_BAG_OPEN CANVAS_BAG_CLOSE
%token <string> CHARACTER_NAME
%token <string> ITEM_NAME
%token <string> PORTRAIT
%token <number> NUMBER

%type <p_adventurer> adventurers adv
%type <bag> a_bag leather_bag silk_bag canvas_bag
%type <p_item> items one_item 
%type <a_party> adventuring_party
%type <string> character_name
%type <string> item_name item_names
  

%%

input: adventuring_party
		{
			print_party($1);
		}
	|
		{
	
		}

adventuring_party: adventurers EOLN
		{
			/* We need to return a party struct here */
			struct party p = {
				NULL,  /*party leader*/
				NULL,  /*party leader*/			
				NULL,  /*first party member*/
			};
			$$ = p;
		}
	;

adventurers: /* add the first production rule here*/
		{
			/* HINT: here we are stiching together two adventurer nodes*/
		}
	| /* Another production rule here*/
	;

adv: /* add the production rule for a single adventurer here */
		{
			/* HINT: here we are creating a single adventurer node */
		}
	;

/*
 * This rule is provided to simplify the recognition of character names 
 */
character_name: CHARACTER_NAME
	| ITEM_NAME
  ;

a_bag: /* a bag can be 3 different types of bags the first one goes here*/
	| /* the second goes here */
	| /* the third goes here */
	;

leather_bag: /* add the production rule for a leather bag with items in it here */
		{
			/* We need to return an adv_bag struct with the type set to LEATHER here */
		}
	| /* the rule for an empty leather bag goes here */
		{
			/* We need to return an adv_bag struct with the type set to LEATHER here 
				 We don't have any items, so what do we set the first item field on the 
				 adv_bag struct to?
			*/
		}
silk_bag: /* add the production rule for a silk bag with items in it here */
		{
			/* We need to return an adv_bag struct with the type set to SILK here */
		}
	| /* the rule for an empty silk bag goes here */
		{
			/* We need to return an adv_bag struct with the type set to SILK here 
				 We don't have any items, so what do we set the first item field on the 
				 adv_bag struct to?
			*/
		}
canvas_bag: /* add the production rule for a canvas bag with items in it here */
		{
			/* We need to return an adv_bag struct with the type set to CANVAS here */
		}
	| /* the rule for an empty canvas bag goes here */
		{
			/* We need to return an adv_bag struct with the type set to CANVAS here 
				 We don't have any items, so what do we set the first item field on the 
				 adv_bag struct to?
			*/
		}

items: /* recursive rule for multiple items */
		{
			/*here we need to stitch together our items linked list*/	
		}
	| // base case for single items or final items
	;

one_item: // the rule for creating a single item
		{
			/*
			* We need to return an item struct pointer here
			* set all the fields and then set the next pointer to what? 
			*/
		}
	;

/* 
 * this rule is provided for you to allow item names to have spaces without 
 * overcomplicating the regular expressions needed
 */
item_names: item_name item_names
		{
			int size1 = strnlen($1, 255);
			int size2 = strnlen($2, 255);
			char* name = (char*) MallocZ(size1 + size2);
			strcat(name, $1);
			strcat(name, " ");
			strcat(name, $2);
			$$ = name;
		}
	| item_name
 	;

item_name: ITEM_NAME
	;

%%

void
yyerror(const char *error_string, ...)
{
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;

    fprintf(f,"Error on line %d: ", lines);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}

// You should use this routine instead of malloc() to avoid some memory problems
#include <stdlib.h>
#include <string.h>
void *
MallocZ (int nbytes)
{
    char *ptr = malloc(nbytes);  // use the real routine
    if (ptr == NULL)
	{
	    perror ("MallocZ failed, fatal\n");
	    exit (66);
	}

	// initialize the space to all zeroes
    memset (ptr, '\00', nbytes);

    return (ptr);
}
